"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["node_modules_ionic_core_dist_esm_ion-modal_entry_js"],{

/***/ 6991:
/*!**************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/ion-modal.entry.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_modal": function() { return /* binding */ Modal; }
/* harmony export */ });
/* harmony import */ var _Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ 9341);
/* harmony import */ var _Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/classCallCheck */ 5960);
/* harmony import */ var _Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createClass */ 9367);
/* harmony import */ var _Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toConsumableArray */ 8035);
/* harmony import */ var _Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ 2783);
/* harmony import */ var _index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index-8e692445.js */ 320);
/* harmony import */ var _ionic_global_c74e4951_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ionic-global-c74e4951.js */ 9656);
/* harmony import */ var _index_e6d1a8be_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./index-e6d1a8be.js */ 139);
/* harmony import */ var _framework_delegate_c3305a28_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./framework-delegate-c3305a28.js */ 4293);
/* harmony import */ var _helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./helpers-3b390e48.js */ 7140);
/* harmony import */ var _keyboard_282b81b8_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./keyboard-282b81b8.js */ 9386);
/* harmony import */ var _index_c4b11676_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./index-c4b11676.js */ 5057);
/* harmony import */ var _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./index-33ffec25.js */ 1356);
/* harmony import */ var _overlays_58fa8e4d_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./overlays-58fa8e4d.js */ 1921);
/* harmony import */ var _theme_7670341c_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./theme-7670341c.js */ 7548);
/* harmony import */ var _index_27c7e5c4_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./index-27c7e5c4.js */ 4784);
/* harmony import */ var _animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./animation-4ff3f603.js */ 3449);
/* harmony import */ var _cubic_bezier_e78d1307_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./cubic-bezier-e78d1307.js */ 9261);
/* harmony import */ var _index_422b6e83_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./index-422b6e83.js */ 9099);
/* harmony import */ var _hardware_back_button_490df115_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./hardware-back-button-490df115.js */ 9222);
/* harmony import */ var _gesture_controller_17060b7c_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./gesture-controller-17060b7c.js */ 4840);






function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
















var Style;

(function (Style) {
  Style["Dark"] = "DARK";
  Style["Light"] = "LIGHT";
  Style["Default"] = "DEFAULT";
})(Style || (Style = {}));

var StatusBar = {
  getEngine: function getEngine() {
    var _a;

    return ((_a = _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w === null || _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w === void 0 ? void 0 : _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w.Capacitor) === null || _a === void 0 ? void 0 : _a.isPluginAvailable('StatusBar')) && (_index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w === null || _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w === void 0 ? void 0 : _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w.Capacitor.Plugins.StatusBar);
  },
  supportsDefaultStatusBarStyle: function supportsDefaultStatusBarStyle() {
    var _a;
    /**
     * The 'DEFAULT' status bar style was added
     * to the @capacitor/status-bar plugin in Capacitor 3.
     * PluginHeaders is only supported in Capacitor 3+,
     * so we can use this to detect Capacitor 3.
     */


    return !!((_a = _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w === null || _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w === void 0 ? void 0 : _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w.Capacitor) === null || _a === void 0 ? void 0 : _a.PluginHeaders);
  },
  setStyle: function setStyle(options) {
    var engine = this.getEngine();

    if (!engine) {
      return;
    }

    engine.setStyle(options);
  },
  getStyle: function () {
    var _getStyle = (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var engine, _yield$engine$getInfo, style;

      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            engine = this.getEngine();

            if (engine) {
              _context.next = 3;
              break;
            }

            return _context.abrupt("return", Style.Default);

          case 3:
            _context.next = 5;
            return engine.getInfo();

          case 5:
            _yield$engine$getInfo = _context.sent;
            style = _yield$engine$getInfo.style;
            return _context.abrupt("return", style);

          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));

    function getStyle() {
      return _getStyle.apply(this, arguments);
    }

    return getStyle;
  }()
};
/**
 * Use y = mx + b to
 * figure out the backdrop value
 * at a particular x coordinate. This
 * is useful when the backdrop does
 * not begin to fade in until after
 * the 0 breakpoint.
 */

var getBackdropValueForSheet = function getBackdropValueForSheet(x, backdropBreakpoint) {
  /**
   * We will use these points:
   * (backdropBreakpoint, 0)
   * (maxBreakpoint, 1)
   * We know that at the beginning breakpoint,
   * the backdrop will be hidden. We also
   * know that at the maxBreakpoint, the backdrop
   * must be fully visible. maxBreakpoint should
   * always be 1 even if the maximum value
   * of the breakpoints array is not 1 since
   * the animation runs from a progress of 0
   * to a progress of 1.
   * m = (y2 - y1) / (x2 - x1)
   *
   * This is simplified from:
   * m = (1 - 0) / (maxBreakpoint - backdropBreakpoint)
   *
   * If the backdropBreakpoint is 1, we return 0 as the
   * backdrop is completely hidden.
   *
   */
  if (backdropBreakpoint === 1) {
    return 0;
  }

  var slope = 1 / (1 - backdropBreakpoint);
  /**
   * From here, compute b which is
   * the backdrop opacity if the offset
   * is 0. If the backdrop does not
   * begin to fade in until after the
   * 0 breakpoint, this b value will be
   * negative. This is fine as we never pass
   * b directly into the animation keyframes.
   * b = y - mx
   * Use a known point: (backdropBreakpoint, 0)
   * This is simplified from:
   * b = 0 - (backdropBreakpoint * slope)
   */

  var b = -(backdropBreakpoint * slope);
  /**
   * Finally, we can now determine the
   * backdrop offset given an arbitrary
   * gesture offset.
   */

  return x * slope + b;
};
/**
 * The tablet/desktop card modal activates
 * when the window width is >= 768.
 * At that point, the presenting element
 * is not transformed, so we do not need to
 * adjust the status bar color.
 *
 * Note: We check supportsDefaultStatusBarStyle so that
 * Capacitor <= 2 users do not get their status bar
 * stuck in an inconsistent state due to a lack of
 * support for Style.Default.
 */


var setCardStatusBarDark = function setCardStatusBarDark() {
  if (!_index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w || _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w.innerWidth >= 768 || !StatusBar.supportsDefaultStatusBarStyle()) {
    return;
  }

  StatusBar.setStyle({
    style: Style.Dark
  });
};

var setCardStatusBarDefault = function setCardStatusBarDefault() {
  var defaultStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Style.Default;

  if (!_index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w || _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_12__.w.innerWidth >= 768 || !StatusBar.supportsDefaultStatusBarStyle()) {
    return;
  }

  StatusBar.setStyle({
    style: defaultStyle
  });
};

var handleCanDismiss = /*#__PURE__*/function () {
  var _ref = (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(el, animation) {
    var shouldDismiss;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!(typeof el.canDismiss !== 'function')) {
            _context2.next = 2;
            break;
          }

          return _context2.abrupt("return");

        case 2:
          _context2.next = 4;
          return el.canDismiss(undefined, _overlays_58fa8e4d_js__WEBPACK_IMPORTED_MODULE_13__.G);

        case 4:
          shouldDismiss = _context2.sent;

          if (shouldDismiss) {
            _context2.next = 7;
            break;
          }

          return _context2.abrupt("return");

        case 7:
          /**
           * If canDismiss resolved after the snap
           * back animation finished, we can
           * dismiss immediately.
           *
           * If canDismiss resolved before the snap
           * back animation finished, we need to
           * wait until the snap back animation is
           * done before dismissing.
           */
          if (animation.isRunning()) {
            animation.onFinish(function () {
              el.dismiss(undefined, 'handler');
            }, {
              oneTimeCallback: true
            });
          } else {
            el.dismiss(undefined, 'handler');
          }

        case 8:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));

  return function handleCanDismiss(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * This function lets us simulate a realistic spring-like animation
 * when swiping down on the modal.
 * There are two forces that we need to use to compute the spring physics:
 *
 * 1. Stiffness, k: This is a measure of resistance applied a spring.
 * 2. Dampening, c: This value has the effect of reducing or preventing oscillation.
 *
 * Using these two values, we can calculate the Spring Force and the Dampening Force
 * to compute the total force applied to a spring.
 *
 * Spring Force: This force pulls a spring back into its equilibrium position.
 * Hooke's Law tells us that that spring force (FS) = kX.
 * k is the stiffness of a spring, and X is the displacement of the spring from its
 * equilibrium position. In this case, it is the amount by which the free end
 * of a spring was displaced (stretched/pushed) from its "relaxed" position.
 *
 * Dampening Force: This force slows down motion. Without it, a spring would oscillate forever.
 * The dampening force, FD, can be found via this formula: FD = -cv
 * where c the dampening value and v is velocity.
 *
 * Therefore, the resulting force that is exerted on the block is:
 * F = FS + FD = -kX - cv
 *
 * Newton's 2nd Law tells us that F = ma:
 * ma = -kX - cv.
 *
 * For Ionic's purposes, we can assume that m = 1:
 * a = -kX - cv
 *
 * Imagine a block attached to the end of a spring. At equilibrium
 * the block is at position x = 1.
 * Pressing on the block moves it to position x = 0;
 * So, to calculate the displacement, we need to take the
 * current position and subtract the previous position from it.
 * X = x - x0 = 0 - 1 = -1.
 *
 * For Ionic's purposes, we are only pushing on the spring modal
 * so we have a max position of 1.
 * As a result, we can expand displacement to this formula:
 * X = x - 1
 *
 * a = -k(x - 1) - cv
 *
 * We can represent the motion of something as a function of time: f(t) = x.
 * The derivative of position gives us the velocity: f'(t)
 * The derivative of the velocity gives us the acceleration: f''(t)
 *
 * We can substitute the formula above with these values:
 *
 * f"(t) = -k * (f(t) - 1) - c * f'(t)
 *
 * This is called a differential equation.
 *
 * We know that at t = 0, we are at x = 0 because the modal does not move: f(0) = 0
 * This means our velocity is also zero: f'(0) = 0.
 *
 * We can cheat a bit and plug the formula into Wolfram Alpha.
 * However, we need to pick stiffness and dampening values:
 * k = 0.57
 * c = 15
 *
 * I picked these as they are fairly close to native iOS's spring effect
 * with the modal.
 *
 * What we plug in is this: f(0) = 0; f'(0) = 0; f''(t) = -0.57(f(t) - 1) - 15f'(t)
 *
 * The result is a formula that lets us calculate the acceleration
 * for a given time t.
 * Note: This is the approximate form of the solution. Wolfram Alpha will
 * give you a complex differential equation too.
 */


var calculateSpringStep = function calculateSpringStep(t) {
  return 0.00255275 * Math.pow(2.71828, -14.9619 * t) - 1.00255 * Math.pow(2.71828, -0.0380968 * t) + 1;
}; // Defaults for the card swipe animation


var SwipeToCloseDefaults = {
  MIN_PRESENTING_SCALE: 0.93
};

var createSwipeToCloseGesture = function createSwipeToCloseGesture(el, animation, statusBarStyle, onDismiss) {
  /**
   * The step value at which a card modal
   * is eligible for dismissing via gesture.
   */
  var DISMISS_THRESHOLD = 0.5;
  var height = el.offsetHeight;
  var isOpen = false;
  var canDismissBlocksGesture = false;
  var contentEl = null;
  var scrollEl = null;
  var canDismissMaxStep = 0.2;
  var initialScrollY = true;
  var lastStep = 0;

  var getScrollY = function getScrollY() {
    if (contentEl && (0,_index_e6d1a8be_js__WEBPACK_IMPORTED_MODULE_7__.i)(contentEl)) {
      return contentEl.scrollY;
      /**
       * Custom scroll containers are intended to be
       * used with virtual scrolling, so we assume
       * there is scrolling in this case.
       */
    } else {
      return true;
    }
  };

  var canStart = function canStart(detail) {
    var target = detail.event.target;

    if (target === null || !target.closest) {
      return true;
    }
    /**
     * If we are swiping on the content,
     * swiping should only be possible if
     * the content is scrolled all the way
     * to the top so that we do not interfere
     * with scrolling.
     *
     * We cannot assume that the `ion-content`
     * target will remain consistent between
     * swipes. For example, when using
     * ion-nav within a card modal it is
     * possible to swipe, push a view, and then
     * swipe again. The target content will not
     * be the same between swipes.
     */


    contentEl = (0,_index_e6d1a8be_js__WEBPACK_IMPORTED_MODULE_7__.f)(target);

    if (contentEl) {
      /**
       * The card should never swipe to close
       * on the content with a refresher.
       * Note: We cannot solve this by making the
       * swipeToClose gesture have a higher priority
       * than the refresher gesture as the iOS native
       * refresh gesture uses a scroll listener in
       * addition to a gesture.
       *
       * Note: Do not use getScrollElement here
       * because we need this to be a synchronous
       * operation, and getScrollElement is
       * asynchronous.
       */
      if ((0,_index_e6d1a8be_js__WEBPACK_IMPORTED_MODULE_7__.i)(contentEl)) {
        var root = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.g)(contentEl);
        scrollEl = root.querySelector('.inner-scroll');
      } else {
        scrollEl = contentEl;
      }

      var hasRefresherInContent = !!contentEl.querySelector('ion-refresher');
      return !hasRefresherInContent && scrollEl.scrollTop === 0;
    }
    /**
     * Card should be swipeable on all
     * parts of the modal except for the footer.
     */


    var footer = target.closest('ion-footer');

    if (footer === null) {
      return true;
    }

    return false;
  };

  var onStart = function onStart(detail) {
    var deltaY = detail.deltaY;
    /**
     * Get the initial scrollY value so
     * that we can correctly reset the scrollY
     * prop when the gesture ends.
     */

    initialScrollY = getScrollY();
    /**
     * If canDismiss is anything other than `true`
     * then users should be able to swipe down
     * until a threshold is hit. At that point,
     * the card modal should not proceed any further.
     * TODO (FW-937)
     * Remove undefined check
     */

    canDismissBlocksGesture = el.canDismiss !== undefined && el.canDismiss !== true;
    /**
     * If we are pulling down, then
     * it is possible we are pulling on the
     * content. We do not want scrolling to
     * happen at the same time as the gesture.
     */

    if (deltaY > 0 && contentEl) {
      (0,_index_e6d1a8be_js__WEBPACK_IMPORTED_MODULE_7__.d)(contentEl);
    }

    animation.progressStart(true, isOpen ? 1 : 0);
  };

  var onMove = function onMove(detail) {
    var deltaY = detail.deltaY;
    /**
     * If we are pulling down, then
     * it is possible we are pulling on the
     * content. We do not want scrolling to
     * happen at the same time as the gesture.
     */

    if (deltaY > 0 && contentEl) {
      (0,_index_e6d1a8be_js__WEBPACK_IMPORTED_MODULE_7__.d)(contentEl);
    }
    /**
     * If we are swiping on the content
     * then the swipe gesture should only
     * happen if we are pulling down.
     *
     * However, if we pull up and
     * then down such that the scroll position
     * returns to 0, we should be able to swipe
     * the card.
     */


    var step = detail.deltaY / height;
    /**
     * Check if user is swiping down and
     * if we have a canDismiss value that
     * should block the gesture from
     * proceeding,
     */

    var isAttemptingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;
    /**
     * If we are blocking the gesture from dismissing,
     * set the max step value so that the sheet cannot be
     * completely hidden.
     */

    var maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    /**
     * If we are blocking the gesture from
     * dismissing, calculate the spring modifier value
     * this will be added to the starting breakpoint
     * value to give the gesture a spring-like feeling.
     * Note that the starting breakpoint is always 0,
     * so we omit adding 0 to the result.
     */

    var processedStep = isAttemptingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;
    var clampedStep = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.l)(0.0001, processedStep, maxStep);
    animation.progressStep(clampedStep);
    /**
     * When swiping down half way, the status bar style
     * should be reset to its default value.
     *
     * We track lastStep so that we do not fire these
     * functions on every onMove, only when the user has
     * crossed a certain threshold.
     */

    if (clampedStep >= DISMISS_THRESHOLD && lastStep < DISMISS_THRESHOLD) {
      setCardStatusBarDefault(statusBarStyle);
      /**
       * However, if we swipe back up, then the
       * status bar style should be set to have light
       * text on a dark background.
       */
    } else if (clampedStep < DISMISS_THRESHOLD && lastStep >= DISMISS_THRESHOLD) {
      setCardStatusBarDark();
    }

    lastStep = clampedStep;
  };

  var onEnd = function onEnd(detail) {
    var velocity = detail.velocityY;
    var step = detail.deltaY / height;
    var isAttemptingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;
    var maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    var processedStep = isAttemptingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;
    var clampedStep = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.l)(0.0001, processedStep, maxStep);
    var threshold = (detail.deltaY + velocity * 1000) / height;
    /**
     * If canDismiss blocks
     * the swipe gesture, then the
     * animation can never complete until
     * canDismiss is checked.
     */

    var shouldComplete = !isAttemptingDismissWithCanDismiss && threshold >= DISMISS_THRESHOLD;
    var newStepValue = shouldComplete ? -0.001 : 0.001;

    if (!shouldComplete) {
      animation.easing('cubic-bezier(1, 0, 0.68, 0.28)');
      newStepValue += (0,_cubic_bezier_e78d1307_js__WEBPACK_IMPORTED_MODULE_17__.g)([0, 0], [1, 0], [0.68, 0.28], [1, 1], clampedStep)[0];
    } else {
      animation.easing('cubic-bezier(0.32, 0.72, 0, 1)');
      newStepValue += (0,_cubic_bezier_e78d1307_js__WEBPACK_IMPORTED_MODULE_17__.g)([0, 0], [0.32, 0.72], [0, 1], [1, 1], clampedStep)[0];
    }

    var duration = shouldComplete ? computeDuration(step * height, velocity) : computeDuration((1 - clampedStep) * height, velocity);
    isOpen = shouldComplete;
    gesture.enable(false);

    if (contentEl) {
      (0,_index_e6d1a8be_js__WEBPACK_IMPORTED_MODULE_7__.r)(contentEl, initialScrollY);
    }

    animation.onFinish(function () {
      if (!shouldComplete) {
        gesture.enable(true);
      }
    }).progressEnd(shouldComplete ? 1 : 0, newStepValue, duration);
    /**
     * If the canDismiss value blocked the gesture
     * from proceeding, then we should ignore whatever
     * shouldComplete is. Whether or not the modal
     * animation should complete is now determined by
     * canDismiss.
     *
     * If the user swiped >25% of the way
     * to the max step, then we should
     * check canDismiss. 25% was chosen
     * to avoid accidental swipes.
     */

    if (isAttemptingDismissWithCanDismiss && clampedStep > maxStep / 4) {
      handleCanDismiss(el, animation);
    } else if (shouldComplete) {
      onDismiss();
    }
  };

  var gesture = (0,_index_422b6e83_js__WEBPACK_IMPORTED_MODULE_18__.createGesture)({
    el: el,
    gestureName: 'modalSwipeToClose',
    gesturePriority: 39,
    direction: 'y',
    threshold: 10,
    canStart: canStart,
    onStart: onStart,
    onMove: onMove,
    onEnd: onEnd
  });
  return gesture;
};

var computeDuration = function computeDuration(remaining, velocity) {
  return (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.l)(400, remaining / Math.abs(velocity * 1.1), 500);
};

var createSheetEnterAnimation = function createSheetEnterAnimation(opts) {
  var currentBreakpoint = opts.currentBreakpoint,
      backdropBreakpoint = opts.backdropBreakpoint;
  /**
   * If the backdropBreakpoint is undefined, then the backdrop
   * should always fade in. If the backdropBreakpoint came before the
   * current breakpoint, then the backdrop should be fading in.
   */

  var shouldShowBackdrop = backdropBreakpoint === undefined || backdropBreakpoint < currentBreakpoint;
  var initialBackdrop = shouldShowBackdrop ? "calc(var(--backdrop-opacity) * ".concat(currentBreakpoint, ")") : '0';
  var backdropAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)('backdropAnimation').fromTo('opacity', 0, initialBackdrop);

  if (shouldShowBackdrop) {
    backdropAnimation.beforeStyles({
      'pointer-events': 'none'
    }).afterClearStyles(['pointer-events']);
  }

  var wrapperAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)('wrapperAnimation').keyframes([{
    offset: 0,
    opacity: 1,
    transform: 'translateY(100%)'
  }, {
    offset: 1,
    opacity: 1,
    transform: "translateY(".concat(100 - currentBreakpoint * 100, "%)")
  }]);
  return {
    wrapperAnimation: wrapperAnimation,
    backdropAnimation: backdropAnimation
  };
};

var createSheetLeaveAnimation = function createSheetLeaveAnimation(opts) {
  var currentBreakpoint = opts.currentBreakpoint,
      backdropBreakpoint = opts.backdropBreakpoint;
  /**
   * Backdrop does not always fade in from 0 to 1 if backdropBreakpoint
   * is defined, so we need to account for that offset by figuring out
   * what the current backdrop value should be.
   */

  var backdropValue = "calc(var(--backdrop-opacity) * ".concat(getBackdropValueForSheet(currentBreakpoint, backdropBreakpoint), ")");
  var defaultBackdrop = [{
    offset: 0,
    opacity: backdropValue
  }, {
    offset: 1,
    opacity: 0
  }];
  var customBackdrop = [{
    offset: 0,
    opacity: backdropValue
  }, {
    offset: backdropBreakpoint,
    opacity: 0
  }, {
    offset: 1,
    opacity: 0
  }];
  var backdropAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)('backdropAnimation').keyframes(backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop);
  var wrapperAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)('wrapperAnimation').keyframes([{
    offset: 0,
    opacity: 1,
    transform: "translateY(".concat(100 - currentBreakpoint * 100, "%)")
  }, {
    offset: 1,
    opacity: 1,
    transform: "translateY(100%)"
  }]);
  return {
    wrapperAnimation: wrapperAnimation,
    backdropAnimation: backdropAnimation
  };
};

var createEnterAnimation$1 = function createEnterAnimation$1() {
  var backdropAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({
    'pointer-events': 'none'
  }).afterClearStyles(['pointer-events']);
  var wrapperAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().fromTo('transform', 'translateY(100vh)', 'translateY(0vh)');
  return {
    backdropAnimation: backdropAnimation,
    wrapperAnimation: wrapperAnimation
  };
};
/**
 * iOS Modal Enter Animation for the Card presentation style
 */


var iosEnterAnimation = function iosEnterAnimation(baseEl, opts) {
  var presentingEl = opts.presentingEl,
      currentBreakpoint = opts.currentBreakpoint;
  var root = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.g)(baseEl);

  var _ref2 = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation$1(),
      wrapperAnimation = _ref2.wrapperAnimation,
      backdropAnimation = _ref2.backdropAnimation;

  backdropAnimation.addElement(root.querySelector('ion-backdrop'));
  wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({
    opacity: 1
  });
  var baseAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)('entering-base').addElement(baseEl).easing('cubic-bezier(0.32,0.72,0,1)').duration(500).addAnimation(wrapperAnimation);

  if (presentingEl) {
    var isMobile = window.innerWidth < 768;
    var hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;
    var presentingElRoot = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.g)(presentingEl);
    var presentingAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().beforeStyles({
      transform: 'translateY(0)',
      'transform-origin': 'top center',
      overflow: 'hidden'
    });
    var bodyEl = document.body;

    if (isMobile) {
      /**
       * Fallback for browsers that does not support `max()` (ex: Firefox)
       * No need to worry about statusbar padding since engines like Gecko
       * are not used as the engine for standalone Cordova/Capacitor apps
       */
      var transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';
      var modalTransform = hasCardModal ? '-10px' : transformOffset;
      var toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
      var finalTransform = "translateY(".concat(modalTransform, ") scale(").concat(toPresentingScale, ")");
      presentingAnimation.afterStyles({
        transform: finalTransform
      }).beforeAddWrite(function () {
        return bodyEl.style.setProperty('background-color', 'black');
      }).addElement(presentingEl).keyframes([{
        offset: 0,
        filter: 'contrast(1)',
        transform: 'translateY(0px) scale(1)',
        borderRadius: '0px'
      }, {
        offset: 1,
        filter: 'contrast(0.85)',
        transform: finalTransform,
        borderRadius: '10px 10px 0 0'
      }]);
      baseAnimation.addAnimation(presentingAnimation);
    } else {
      baseAnimation.addAnimation(backdropAnimation);

      if (!hasCardModal) {
        wrapperAnimation.fromTo('opacity', '0', '1');
      } else {
        var _toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;

        var _finalTransform = "translateY(-10px) scale(".concat(_toPresentingScale, ")");

        presentingAnimation.afterStyles({
          transform: _finalTransform
        }).addElement(presentingElRoot.querySelector('.modal-wrapper')).keyframes([{
          offset: 0,
          filter: 'contrast(1)',
          transform: 'translateY(0) scale(1)'
        }, {
          offset: 1,
          filter: 'contrast(0.85)',
          transform: _finalTransform
        }]);
        var shadowAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().afterStyles({
          transform: _finalTransform
        }).addElement(presentingElRoot.querySelector('.modal-shadow')).keyframes([{
          offset: 0,
          opacity: '1',
          transform: 'translateY(0) scale(1)'
        }, {
          offset: 1,
          opacity: '0',
          transform: _finalTransform
        }]);
        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);
      }
    }
  } else {
    baseAnimation.addAnimation(backdropAnimation);
  }

  return baseAnimation;
};

var createLeaveAnimation$1 = function createLeaveAnimation$1() {
  var backdropAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().fromTo('opacity', 'var(--backdrop-opacity)', 0);
  var wrapperAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().fromTo('transform', 'translateY(0vh)', 'translateY(100vh)');
  return {
    backdropAnimation: backdropAnimation,
    wrapperAnimation: wrapperAnimation
  };
};
/**
 * iOS Modal Leave Animation
 */


var iosLeaveAnimation = function iosLeaveAnimation(baseEl, opts) {
  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;
  var presentingEl = opts.presentingEl,
      currentBreakpoint = opts.currentBreakpoint;
  var root = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.g)(baseEl);

  var _ref3 = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation$1(),
      wrapperAnimation = _ref3.wrapperAnimation,
      backdropAnimation = _ref3.backdropAnimation;

  backdropAnimation.addElement(root.querySelector('ion-backdrop'));
  wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({
    opacity: 1
  });
  var baseAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)('leaving-base').addElement(baseEl).easing('cubic-bezier(0.32,0.72,0,1)').duration(duration).addAnimation(wrapperAnimation);

  if (presentingEl) {
    var isMobile = window.innerWidth < 768;
    var hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;
    var presentingElRoot = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.g)(presentingEl);
    var presentingAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().beforeClearStyles(['transform']).afterClearStyles(['transform']).onFinish(function (currentStep) {
      // only reset background color if this is the last card-style modal
      if (currentStep !== 1) {
        return;
      }

      presentingEl.style.setProperty('overflow', '');
      var numModals = Array.from(bodyEl.querySelectorAll('ion-modal')).filter(function (m) {
        return m.presentingElement !== undefined;
      }).length;

      if (numModals <= 1) {
        bodyEl.style.setProperty('background-color', '');
      }
    });
    var bodyEl = document.body;

    if (isMobile) {
      var transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';
      var modalTransform = hasCardModal ? '-10px' : transformOffset;
      var toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
      var finalTransform = "translateY(".concat(modalTransform, ") scale(").concat(toPresentingScale, ")");
      presentingAnimation.addElement(presentingEl).keyframes([{
        offset: 0,
        filter: 'contrast(0.85)',
        transform: finalTransform,
        borderRadius: '10px 10px 0 0'
      }, {
        offset: 1,
        filter: 'contrast(1)',
        transform: 'translateY(0px) scale(1)',
        borderRadius: '0px'
      }]);
      baseAnimation.addAnimation(presentingAnimation);
    } else {
      baseAnimation.addAnimation(backdropAnimation);

      if (!hasCardModal) {
        wrapperAnimation.fromTo('opacity', '1', '0');
      } else {
        var _toPresentingScale2 = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;

        var _finalTransform2 = "translateY(-10px) scale(".concat(_toPresentingScale2, ")");

        presentingAnimation.addElement(presentingElRoot.querySelector('.modal-wrapper')).afterStyles({
          transform: 'translate3d(0, 0, 0)'
        }).keyframes([{
          offset: 0,
          filter: 'contrast(0.85)',
          transform: _finalTransform2
        }, {
          offset: 1,
          filter: 'contrast(1)',
          transform: 'translateY(0) scale(1)'
        }]);
        var shadowAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().addElement(presentingElRoot.querySelector('.modal-shadow')).afterStyles({
          transform: 'translateY(0) scale(1)'
        }).keyframes([{
          offset: 0,
          opacity: '0',
          transform: _finalTransform2
        }, {
          offset: 1,
          opacity: '1',
          transform: 'translateY(0) scale(1)'
        }]);
        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);
      }
    }
  } else {
    baseAnimation.addAnimation(backdropAnimation);
  }

  return baseAnimation;
};

var createEnterAnimation = function createEnterAnimation() {
  var backdropAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({
    'pointer-events': 'none'
  }).afterClearStyles(['pointer-events']);
  var wrapperAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().keyframes([{
    offset: 0,
    opacity: 0.01,
    transform: 'translateY(40px)'
  }, {
    offset: 1,
    opacity: 1,
    transform: "translateY(0px)"
  }]);
  return {
    backdropAnimation: backdropAnimation,
    wrapperAnimation: wrapperAnimation
  };
};
/**
 * Md Modal Enter Animation
 */


var mdEnterAnimation = function mdEnterAnimation(baseEl, opts) {
  var currentBreakpoint = opts.currentBreakpoint;
  var root = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.g)(baseEl);

  var _ref4 = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation(),
      wrapperAnimation = _ref4.wrapperAnimation,
      backdropAnimation = _ref4.backdropAnimation;

  backdropAnimation.addElement(root.querySelector('ion-backdrop'));
  wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));
  return (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().addElement(baseEl).easing('cubic-bezier(0.36,0.66,0.04,1)').duration(280).addAnimation([backdropAnimation, wrapperAnimation]);
};

var createLeaveAnimation = function createLeaveAnimation() {
  var backdropAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().fromTo('opacity', 'var(--backdrop-opacity)', 0);
  var wrapperAnimation = (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().keyframes([{
    offset: 0,
    opacity: 0.99,
    transform: "translateY(0px)"
  }, {
    offset: 1,
    opacity: 0,
    transform: 'translateY(40px)'
  }]);
  return {
    backdropAnimation: backdropAnimation,
    wrapperAnimation: wrapperAnimation
  };
};
/**
 * Md Modal Leave Animation
 */


var mdLeaveAnimation = function mdLeaveAnimation(baseEl, opts) {
  var currentBreakpoint = opts.currentBreakpoint;
  var root = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.g)(baseEl);

  var _ref5 = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation(),
      wrapperAnimation = _ref5.wrapperAnimation,
      backdropAnimation = _ref5.backdropAnimation;

  backdropAnimation.addElement(root.querySelector('ion-backdrop'));
  wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));
  return (0,_animation_4ff3f603_js__WEBPACK_IMPORTED_MODULE_16__.c)().easing('cubic-bezier(0.47,0,0.745,0.715)').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};

var createSheetGesture = function createSheetGesture(baseEl, backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, animation) {
  var breakpoints = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
  var getCurrentBreakpoint = arguments.length > 7 ? arguments[7] : undefined;
  var onDismiss = arguments.length > 8 ? arguments[8] : undefined;
  var onBreakpointChange = arguments.length > 9 ? arguments[9] : undefined;
  // Defaults for the sheet swipe animation
  var defaultBackdrop = [{
    offset: 0,
    opacity: 'var(--backdrop-opacity)'
  }, {
    offset: 1,
    opacity: 0.01
  }];
  var customBackdrop = [{
    offset: 0,
    opacity: 'var(--backdrop-opacity)'
  }, {
    offset: 1 - backdropBreakpoint,
    opacity: 0
  }, {
    offset: 1,
    opacity: 0
  }];
  var SheetDefaults = {
    WRAPPER_KEYFRAMES: [{
      offset: 0,
      transform: 'translateY(0%)'
    }, {
      offset: 1,
      transform: 'translateY(100%)'
    }],
    BACKDROP_KEYFRAMES: backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop
  };
  var contentEl = baseEl.querySelector('ion-content');
  var height = wrapperEl.clientHeight;
  var currentBreakpoint = initialBreakpoint;
  var offset = 0;
  var canDismissBlocksGesture = false;
  var canDismissMaxStep = 0.95;
  var wrapperAnimation = animation.childAnimations.find(function (ani) {
    return ani.id === 'wrapperAnimation';
  });
  var backdropAnimation = animation.childAnimations.find(function (ani) {
    return ani.id === 'backdropAnimation';
  });
  var maxBreakpoint = breakpoints[breakpoints.length - 1];
  var minBreakpoint = breakpoints[0];

  var enableBackdrop = function enableBackdrop() {
    baseEl.style.setProperty('pointer-events', 'auto');
    backdropEl.style.setProperty('pointer-events', 'auto');
    /**
     * When the backdrop is enabled, elements such
     * as inputs should not be focusable outside
     * the sheet.
     */

    baseEl.classList.remove('ion-disable-focus-trap');
  };

  var disableBackdrop = function disableBackdrop() {
    baseEl.style.setProperty('pointer-events', 'none');
    backdropEl.style.setProperty('pointer-events', 'none');
    /**
     * When the backdrop is enabled, elements such
     * as inputs should not be focusable outside
     * the sheet.
     * Adding this class disables focus trapping
     * for the sheet temporarily.
     */

    baseEl.classList.add('ion-disable-focus-trap');
  };
  /**
   * After the entering animation completes,
   * we need to set the animation to go from
   * offset 0 to offset 1 so that users can
   * swipe in any direction. We then set the
   * animation offset to the current breakpoint
   * so there is no flickering.
   */


  if (wrapperAnimation && backdropAnimation) {
    wrapperAnimation.keyframes((0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__["default"])(SheetDefaults.WRAPPER_KEYFRAMES));
    backdropAnimation.keyframes((0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__["default"])(SheetDefaults.BACKDROP_KEYFRAMES));
    animation.progressStart(true, 1 - currentBreakpoint);
    /**
     * If backdrop is not enabled, then content
     * behind modal should be clickable. To do this, we need
     * to remove pointer-events from ion-modal as a whole.
     * ion-backdrop and .modal-wrapper always have pointer-events: auto
     * applied, so the modal content can still be interacted with.
     */

    var shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;

    if (shouldEnableBackdrop) {
      enableBackdrop();
    } else {
      disableBackdrop();
    }
  }

  if (contentEl && currentBreakpoint !== maxBreakpoint) {
    contentEl.scrollY = false;
  }

  var canStart = function canStart(detail) {
    /**
     * If the sheet is fully expanded and
     * the user is swiping on the content,
     * the gesture should not start to
     * allow for scrolling on the content.
     */
    var content = detail.event.target.closest('ion-content');
    currentBreakpoint = getCurrentBreakpoint();

    if (currentBreakpoint === 1 && content) {
      return false;
    }

    return true;
  };

  var onStart = function onStart() {
    /**
     * If canDismiss is anything other than `true`
     * then users should be able to swipe down
     * until a threshold is hit. At that point,
     * the card modal should not proceed any further.
     *
     * canDismiss is never fired via gesture if there is
     * no 0 breakpoint. However, it can be fired if the user
     * presses Esc or the hardware back button.
     * TODO (FW-937)
     * Remove undefined check
     */
    canDismissBlocksGesture = baseEl.canDismiss !== undefined && baseEl.canDismiss !== true && minBreakpoint === 0;
    /**
     * If swiping on the content
     * we should disable scrolling otherwise
     * the sheet will expand and the content will scroll.
     */

    if (contentEl) {
      contentEl.scrollY = false;
    }

    (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.r)(function () {
      /**
       * Dismisses the open keyboard when the sheet drag gesture is started.
       * Sets the focus onto the modal element.
       */
      baseEl.focus();
    });
    animation.progressStart(true, 1 - currentBreakpoint);
  };

  var onMove = function onMove(detail) {
    /**
     * Given the change in gesture position on the Y axis,
     * compute where the offset of the animation should be
     * relative to where the user dragged.
     */
    var initialStep = 1 - currentBreakpoint;
    var secondToLastBreakpoint = breakpoints.length > 1 ? 1 - breakpoints[1] : undefined;
    var step = initialStep + detail.deltaY / height;
    var isAttemptingDismissWithCanDismiss = secondToLastBreakpoint !== undefined && step >= secondToLastBreakpoint && canDismissBlocksGesture;
    /**
     * If we are blocking the gesture from dismissing,
     * set the max step value so that the sheet cannot be
     * completely hidden.
     */

    var maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    /**
     * If we are blocking the gesture from
     * dismissing, calculate the spring modifier value
     * this will be added to the starting breakpoint
     * value to give the gesture a spring-like feeling.
     * Note that when isAttemptingDismissWithCanDismiss is true,
     * the modifier is always added to the breakpoint that
     * appears right after the 0 breakpoint.
     *
     * Note that this modifier is essentially the progression
     * between secondToLastBreakpoint and maxStep which is
     * why we subtract secondToLastBreakpoint. This lets us get
     * the result as a value from 0 to 1.
     */

    var processedStep = isAttemptingDismissWithCanDismiss && secondToLastBreakpoint !== undefined ? secondToLastBreakpoint + calculateSpringStep((step - secondToLastBreakpoint) / (maxStep - secondToLastBreakpoint)) : step;
    offset = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.l)(0.0001, processedStep, maxStep);
    animation.progressStep(offset);
  };

  var onEnd = function onEnd(detail) {
    /**
     * When the gesture releases, we need to determine
     * the closest breakpoint to snap to.
     */
    var velocity = detail.velocityY;
    var threshold = (detail.deltaY + velocity * 350) / height;
    var diff = currentBreakpoint - threshold;
    var closest = breakpoints.reduce(function (a, b) {
      return Math.abs(b - diff) < Math.abs(a - diff) ? b : a;
    });
    moveSheetToBreakpoint({
      breakpoint: closest,
      breakpointOffset: offset,
      canDismiss: canDismissBlocksGesture
    });
  };

  var moveSheetToBreakpoint = function moveSheetToBreakpoint(options) {
    var breakpoint = options.breakpoint,
        canDismiss = options.canDismiss,
        breakpointOffset = options.breakpointOffset;
    /**
     * canDismiss should only prevent snapping
     * when users are trying to dismiss. If canDismiss
     * is present but the user is trying to swipe upwards,
     * we should allow that to happen,
     */

    var shouldPreventDismiss = canDismiss && breakpoint === 0;
    var snapToBreakpoint = shouldPreventDismiss ? currentBreakpoint : breakpoint;
    var shouldRemainOpen = snapToBreakpoint !== 0;
    currentBreakpoint = 0;
    /**
     * Update the animation so that it plays from
     * the last offset to the closest snap point.
     */

    if (wrapperAnimation && backdropAnimation) {
      wrapperAnimation.keyframes([{
        offset: 0,
        transform: "translateY(".concat(breakpointOffset * 100, "%)")
      }, {
        offset: 1,
        transform: "translateY(".concat((1 - snapToBreakpoint) * 100, "%)")
      }]);
      backdropAnimation.keyframes([{
        offset: 0,
        opacity: "calc(var(--backdrop-opacity) * ".concat(getBackdropValueForSheet(1 - breakpointOffset, backdropBreakpoint), ")")
      }, {
        offset: 1,
        opacity: "calc(var(--backdrop-opacity) * ".concat(getBackdropValueForSheet(snapToBreakpoint, backdropBreakpoint), ")")
      }]);
      animation.progressStep(0);
    }
    /**
     * Gesture should remain disabled until the
     * snapping animation completes.
     */


    gesture.enable(false);

    if (shouldPreventDismiss) {
      handleCanDismiss(baseEl, animation);
    } else if (!shouldRemainOpen) {
      onDismiss();
    }

    return new Promise(function (resolve) {
      animation.onFinish(function () {
        if (shouldRemainOpen) {
          /**
           * Once the snapping animation completes,
           * we need to reset the animation to go
           * from 0 to 1 so users can swipe in any direction.
           * We then set the animation offset to the current
           * breakpoint so that it starts at the snapped position.
           */
          if (wrapperAnimation && backdropAnimation) {
            (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.r)(function () {
              wrapperAnimation.keyframes((0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__["default"])(SheetDefaults.WRAPPER_KEYFRAMES));
              backdropAnimation.keyframes((0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__["default"])(SheetDefaults.BACKDROP_KEYFRAMES));
              animation.progressStart(true, 1 - snapToBreakpoint);
              currentBreakpoint = snapToBreakpoint;
              onBreakpointChange(currentBreakpoint);
              /**
               * If the sheet is fully expanded, we can safely
               * enable scrolling again.
               */

              if (contentEl && currentBreakpoint === breakpoints[breakpoints.length - 1]) {
                contentEl.scrollY = true;
              }
              /**
               * Backdrop should become enabled
               * after the backdropBreakpoint value
               */


              var shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;

              if (shouldEnableBackdrop) {
                enableBackdrop();
              } else {
                disableBackdrop();
              }

              gesture.enable(true);
              resolve();
            });
          } else {
            gesture.enable(true);
            resolve();
          }
        } else {
          resolve();
        }
        /**
         * This must be a one time callback
         * otherwise a new callback will
         * be added every time onEnd runs.
         */

      }, {
        oneTimeCallback: true
      }).progressEnd(1, 0, 500);
    });
  };

  var gesture = (0,_index_422b6e83_js__WEBPACK_IMPORTED_MODULE_18__.createGesture)({
    el: wrapperEl,
    gestureName: 'modalSheet',
    gesturePriority: 40,
    direction: 'y',
    threshold: 10,
    canStart: canStart,
    onStart: onStart,
    onMove: onMove,
    onEnd: onEnd
  });
  return {
    gesture: gesture,
    moveSheetToBreakpoint: moveSheetToBreakpoint
  };
};

var modalIosCss = ":host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;contain:strict}.modal-wrapper,ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;margin-left:auto;margin-right:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);border:0;background:var(--ion-color-step-350, #c0c0be);cursor:pointer;z-index:11}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.modal-handle::before{padding-left:4px;padding-right:4px;padding-top:4px;padding-bottom:4px;position:absolute;width:36px;height:5px;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);content:\"\"}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle::before{padding-left:unset;padding-right:unset;-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px}}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.4)}:host(.modal-card),:host(.modal-sheet){--border-radius:10px}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:10px}}.modal-wrapper{-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0)}@media screen and (max-width: 767px){@supports (width: 1px){:host(.modal-card){--height:calc(100% - max(30px, var(--ion-safe-area-top)) - 10px)}}@supports not (width: 1px){:host(.modal-card){--height:calc(100% - 40px)}}:host(.modal-card) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-card) .modal-wrapper,:host-context([dir=rtl]).modal-card .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host(.modal-card){--backdrop-opacity:0;--width:100%;-ms-flex-align:end;align-items:flex-end}:host(.modal-card) .modal-shadow{display:none}:host(.modal-card) ion-backdrop{pointer-events:none}}@media screen and (min-width: 768px){:host(.modal-card){--width:calc(100% - 120px);--height:calc(100% - (120px + var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));--max-width:720px;--max-height:1000px;--backdrop-opacity:0;--box-shadow:0px 0px 30px 10px rgba(0, 0, 0, 0.1);-webkit-transition:all 0.5s ease-in-out;transition:all 0.5s ease-in-out}:host(.modal-card) .modal-wrapper{-webkit-box-shadow:none;box-shadow:none}:host(.modal-card) .modal-shadow{-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow)}}:host(.modal-sheet) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-sheet) .modal-wrapper,:host-context([dir=rtl]).modal-sheet .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}";
var modalMdCss = ":host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;contain:strict}.modal-wrapper,ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;margin-left:auto;margin-right:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);border:0;background:var(--ion-color-step-350, #c0c0be);cursor:pointer;z-index:11}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.modal-handle::before{padding-left:4px;padding-right:4px;padding-top:4px;padding-bottom:4px;position:absolute;width:36px;height:5px;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);content:\"\"}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle::before{padding-left:unset;padding-right:unset;-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px}}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:2px;--box-shadow:0 28px 48px rgba(0, 0, 0, 0.4)}}.modal-wrapper{-webkit-transform:translate3d(0,  40px,  0);transform:translate3d(0,  40px,  0);opacity:0.01}";

var Modal = /*#__PURE__*/function () {
  function Modal(hostRef) {
    var _this = this;

    (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Modal);

    (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.r)(this, hostRef);
    this.didPresent = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "ionModalDidPresent", 7);
    this.willPresent = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "ionModalWillPresent", 7);
    this.willDismiss = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "ionModalWillDismiss", 7);
    this.didDismiss = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "ionModalDidDismiss", 7);
    this.ionBreakpointDidChange = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "ionBreakpointDidChange", 7);
    this.didPresentShorthand = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "didPresent", 7);
    this.willPresentShorthand = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "willPresent", 7);
    this.willDismissShorthand = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "willDismiss", 7);
    this.didDismissShorthand = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "didDismiss", 7);
    this.modalIndex = modalIds++;
    this.coreDelegate = (0,_framework_delegate_c3305a28_js__WEBPACK_IMPORTED_MODULE_8__.C)();
    this.isSheetModal = false;
    this.inheritedAttributes = {};
    this.inline = false; // Whether or not modal is being dismissed via gesture

    this.gestureAnimationDismissing = false;
    this.presented = false;
    /** @internal */

    this.hasController = false;
    /**
     * If `true`, the keyboard will be automatically dismissed when the overlay is presented.
     */

    this.keyboardClose = true;
    /**
     * A decimal value between 0 and 1 that indicates the
     * point after which the backdrop will begin to fade in
     * when using a sheet modal. Prior to this point, the
     * backdrop will be hidden and the content underneath
     * the sheet can be interacted with. This value is exclusive
     * meaning the backdrop will become active after the value
     * specified.
     */

    this.backdropBreakpoint = 0;
    /**
     * The interaction behavior for the sheet modal when the handle is pressed.
     *
     * Defaults to `"none"`, which  means the modal will not change size or position when the handle is pressed.
     * Set to `"cycle"` to let the modal cycle between available breakpoints when pressed.
     *
     * Handle behavior is unavailable when the `handle` property is set to `false` or
     * when the `breakpoints` property is not set (using a fullscreen or card modal).
     */

    this.handleBehavior = 'none';
    /**
     * If `true`, the modal will be dismissed when the backdrop is clicked.
     */

    this.backdropDismiss = true;
    /**
     * If `true`, a backdrop will be displayed behind the modal.
     * This property controls whether or not the backdrop
     * darkens the screen when the modal is presented.
     * It does not control whether or not the backdrop
     * is active or present in the DOM.
     */

    this.showBackdrop = true;
    /**
     * If `true`, the modal will animate.
     */

    this.animated = true;
    /**
     * If `true`, the modal can be swiped to dismiss. Only applies in iOS mode.
     * @deprecated - To prevent modals from dismissing, use canDismiss instead.
     */

    this.swipeToClose = false;
    /**
     * If `true`, the modal will open. If `false`, the modal will close.
     * Use this if you need finer grained control over presentation, otherwise
     * just use the modalController or the `trigger` property.
     * Note: `isOpen` will not automatically be set back to `false` when
     * the modal dismisses. You will need to do that in your code.
     */

    this.isOpen = false;
    /**
     * If `true`, the component passed into `ion-modal` will
     * automatically be mounted when the modal is created. The
     * component will remain mounted even when the modal is dismissed.
     * However, the component will be destroyed when the modal is
     * destroyed. This property is not reactive and should only be
     * used when initially creating a modal.
     *
     * Note: This feature only applies to inline modals in JavaScript
     * frameworks such as Angular, React, and Vue.
     */

    this.keepContentsMounted = false;

    this.configureTriggerInteraction = function () {
      var trigger = _this.trigger,
          el = _this.el,
          destroyTriggerInteraction = _this.destroyTriggerInteraction;

      if (destroyTriggerInteraction) {
        destroyTriggerInteraction();
      }

      if (trigger === undefined) {
        return;
      }

      var triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;

      if (!triggerEl) {
        (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_11__.p)("A trigger element with the ID \"".concat(trigger, "\" was not found in the DOM. The trigger element must be in the DOM when the \"trigger\" property is set on ion-modal."), _this.el);
        return;
      }

      var configureTriggerInteraction = function configureTriggerInteraction(trigEl, modalEl) {
        var openModal = function openModal() {
          modalEl.present();
        };

        trigEl.addEventListener('click', openModal);
        return function () {
          trigEl.removeEventListener('click', openModal);
        };
      };

      _this.destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);
    };

    this.onHandleClick = function () {
      var sheetTransition = _this.sheetTransition,
          handleBehavior = _this.handleBehavior;

      if (handleBehavior !== 'cycle' || sheetTransition !== undefined) {
        /**
         * The sheet modal should not advance to the next breakpoint
         * if the handle behavior is not `cycle` or if the handle
         * is clicked while the sheet is moving to a breakpoint.
         */
        return;
      }

      _this.moveToNextBreakpoint();
    };

    this.onBackdropTap = function () {
      var sheetTransition = _this.sheetTransition;

      if (sheetTransition !== undefined) {
        /**
         * When the handle is double clicked at the largest breakpoint,
         * it will start to move to the first breakpoint. While transitioning,
         * the backdrop will often receive the second click. We prevent the
         * backdrop from dismissing the modal while moving between breakpoints.
         */
        return;
      }

      _this.dismiss(undefined, _overlays_58fa8e4d_js__WEBPACK_IMPORTED_MODULE_13__.B);
    };

    this.onLifecycle = function (modalEvent) {
      var el = _this.usersElement;
      var name = LIFECYCLE_MAP[modalEvent.type];

      if (el && name) {
        var ev = new CustomEvent(name, {
          bubbles: false,
          cancelable: false,
          detail: modalEvent.detail
        });
        el.dispatchEvent(ev);
      }
    };
  }

  (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(Modal, [{
    key: "onIsOpenChange",
    value: function onIsOpenChange(newValue, oldValue) {
      if (newValue === true && oldValue === false) {
        this.present();
      } else if (newValue === false && oldValue === true) {
        this.dismiss();
      }
    }
  }, {
    key: "onTriggerChange",
    value: function onTriggerChange() {
      this.configureTriggerInteraction();
    }
  }, {
    key: "swipeToCloseChanged",
    value: function () {
      var _swipeToCloseChanged = (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(enable) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (this.gesture) {
                this.gesture.enable(enable);
              } else if (enable) {
                this.initSwipeToClose();
              }

            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function swipeToCloseChanged(_x3) {
        return _swipeToCloseChanged.apply(this, arguments);
      }

      return swipeToCloseChanged;
    }()
  }, {
    key: "breakpointsChanged",
    value: function breakpointsChanged(breakpoints) {
      if (breakpoints !== undefined) {
        this.sortedBreakpoints = breakpoints.sort(function (a, b) {
          return a - b;
        });
      }
    }
  }, {
    key: "connectedCallback",
    value: function connectedCallback() {
      var configureTriggerInteraction = this.configureTriggerInteraction,
          el = this.el;
      (0,_overlays_58fa8e4d_js__WEBPACK_IMPORTED_MODULE_13__.e)(el);
      configureTriggerInteraction();
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      var destroyTriggerInteraction = this.destroyTriggerInteraction;

      if (destroyTriggerInteraction) {
        destroyTriggerInteraction();
      }
    }
  }, {
    key: "componentWillLoad",
    value: function componentWillLoad() {
      var breakpoints = this.breakpoints,
          initialBreakpoint = this.initialBreakpoint,
          swipeToClose = this.swipeToClose,
          el = this.el;
      this.inheritedAttributes = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.j)(el, ['aria-label', 'role']);
      /**
       * If user has custom ID set then we should
       * not assign the default incrementing ID.
       */

      this.modalId = this.el.hasAttribute('id') ? this.el.getAttribute('id') : "ion-modal-".concat(this.modalIndex);
      var isSheetModal = this.isSheetModal = breakpoints !== undefined && initialBreakpoint !== undefined;

      if (isSheetModal) {
        this.currentBreakpoint = this.initialBreakpoint;
      }

      if (breakpoints !== undefined && initialBreakpoint !== undefined && !breakpoints.includes(initialBreakpoint)) {
        (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_11__.p)('Your breakpoints array must include the initialBreakpoint value.');
      }

      if (swipeToClose) {
        (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_11__.p)('swipeToClose has been deprecated in favor of canDismiss.\n\nIf you want a card modal to be swipeable, set canDismiss to `true`. In the next major release of Ionic, swipeToClose will be removed, and all card modals will be swipeable by default.');
      }
    }
  }, {
    key: "componentDidLoad",
    value: function componentDidLoad() {
      var _this2 = this;

      /**
       * If modal was rendered with isOpen="true"
       * then we should open modal immediately.
       */
      if (this.isOpen === true) {
        (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.r)(function () {
          return _this2.present();
        });
      }

      this.breakpointsChanged(this.breakpoints);
    }
    /**
     * Determines whether or not an overlay
     * is being used inline or via a controller/JS
     * and returns the correct delegate.
     * By default, subsequent calls to getDelegate
     * will use a cached version of the delegate.
     * This is useful for calling dismiss after
     * present so that the correct delegate is given.
     */

  }, {
    key: "getDelegate",
    value: function getDelegate() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.workingDelegate && !force) {
        return {
          delegate: this.workingDelegate,
          inline: this.inline
        };
      }
      /**
       * If using overlay inline
       * we potentially need to use the coreDelegate
       * so that this works in vanilla JS apps.
       * If a developer has presented this component
       * via a controller, then we can assume
       * the component is already in the
       * correct place.
       */


      var parentEl = this.el.parentNode;
      var inline = this.inline = parentEl !== null && !this.hasController;
      var delegate = this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate;
      return {
        inline: inline,
        delegate: delegate
      };
    }
    /**
     * Determines whether or not the
     * modal is allowed to dismiss based
     * on the state of the canDismiss prop.
     */

  }, {
    key: "checkCanDismiss",
    value: function () {
      var _checkCanDismiss = (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(data, role) {
        var canDismiss;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              canDismiss = this.canDismiss;
              /**
               * TODO (FW-937) - Remove the following check in
               * the next major release of Ionic.
               */

              if (!(canDismiss === undefined)) {
                _context4.next = 3;
                break;
              }

              return _context4.abrupt("return", true);

            case 3:
              if (!(typeof canDismiss === 'function')) {
                _context4.next = 5;
                break;
              }

              return _context4.abrupt("return", canDismiss(data, role));

            case 5:
              return _context4.abrupt("return", canDismiss);

            case 6:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function checkCanDismiss(_x4, _x5) {
        return _checkCanDismiss.apply(this, arguments);
      }

      return checkCanDismiss;
    }()
    /**
     * Present the modal overlay after it has been created.
     */

  }, {
    key: "present",
    value: function () {
      var _present2 = (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _this3 = this;

        var _this$getDelegate, inline, delegate, hasCardModal;

        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!this.presented) {
                _context5.next = 2;
                break;
              }

              return _context5.abrupt("return");

            case 2:
              if (!(this.currentTransition !== undefined)) {
                _context5.next = 5;
                break;
              }

              _context5.next = 5;
              return this.currentTransition;

            case 5:
              /**
               * If the modal is presented multiple times (inline modals), we
               * need to reset the current breakpoint to the initial breakpoint.
               */
              this.currentBreakpoint = this.initialBreakpoint;
              _this$getDelegate = this.getDelegate(true), inline = _this$getDelegate.inline, delegate = _this$getDelegate.delegate;
              _context5.next = 9;
              return (0,_framework_delegate_c3305a28_js__WEBPACK_IMPORTED_MODULE_8__.a)(delegate, this.el, this.component, ['ion-page'], this.componentProps, inline);

            case 9:
              this.usersElement = _context5.sent;
              _context5.next = 12;
              return (0,_index_27c7e5c4_js__WEBPACK_IMPORTED_MODULE_15__.e)(this.usersElement);

            case 12:
              (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.c)(function () {
                return _this3.el.classList.add('show-modal');
              });
              this.currentTransition = (0,_overlays_58fa8e4d_js__WEBPACK_IMPORTED_MODULE_13__.d)(this, 'modalEnter', iosEnterAnimation, mdEnterAnimation, {
                presentingEl: this.presentingElement,
                currentBreakpoint: this.initialBreakpoint,
                backdropBreakpoint: this.backdropBreakpoint
              });
              /* tslint:disable-next-line */

              if (typeof window !== 'undefined') {
                /**
                 * This needs to be setup before any
                 * non-transition async work so it can be dereferenced
                 * in the dismiss method. The dismiss method
                 * only waits for the entering transition
                 * to finish. It does not wait for all of the `present`
                 * method to resolve.
                 */
                this.keyboardOpenCallback = function () {
                  if (_this3.gesture) {
                    /**
                     * When the native keyboard is opened and the webview
                     * is resized, the gesture implementation will become unresponsive
                     * and enter a free-scroll mode.
                     *
                     * When the keyboard is opened, we disable the gesture for
                     * a single frame and re-enable once the contents have repositioned
                     * from the keyboard placement.
                     */
                    _this3.gesture.enable(false);

                    (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_9__.r)(function () {
                      if (_this3.gesture) {
                        _this3.gesture.enable(true);
                      }
                    });
                  }
                };

                window.addEventListener(_keyboard_282b81b8_js__WEBPACK_IMPORTED_MODULE_10__.KEYBOARD_DID_OPEN, this.keyboardOpenCallback);
              }
              /**
               * TODO (FW-937) - In the next major release of Ionic, all card modals
               * will be swipeable by default. canDismiss will be used to determine if the
               * modal can be dismissed. This check should change to check the presence of
               * presentingElement instead.
               *
               * If we did not do this check, then not using swipeToClose would mean you could
               * not run canDismiss on swipe as there would be no swipe gesture created.
               */


              hasCardModal = this.presentingElement !== undefined && (this.swipeToClose || this.canDismiss !== undefined);
              /**
               * We need to change the status bar at the
               * start of the animation so that it completes
               * by the time the card animation is done.
               */

              if (!(hasCardModal && (0,_ionic_global_c74e4951_js__WEBPACK_IMPORTED_MODULE_6__.b)(this) === 'ios')) {
                _context5.next = 21;
                break;
              }

              _context5.next = 19;
              return StatusBar.getStyle();

            case 19:
              this.statusBarStyle = _context5.sent;
              setCardStatusBarDark();

            case 21:
              _context5.next = 23;
              return this.currentTransition;

            case 23:
              if (this.isSheetModal) {
                this.initSheetGesture();
              } else if (hasCardModal) {
                this.initSwipeToClose();
              }

              this.currentTransition = undefined;

            case 25:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function present() {
        return _present2.apply(this, arguments);
      }

      return present;
    }()
  }, {
    key: "initSwipeToClose",
    value: function initSwipeToClose() {
      var _this4 = this;

      var _a;

      if ((0,_ionic_global_c74e4951_js__WEBPACK_IMPORTED_MODULE_6__.b)(this) !== 'ios') {
        return;
      }

      var el = this.el; // All of the elements needed for the swipe gesture
      // should be in the DOM and referenced by now, except
      // for the presenting el

      var animationBuilder = this.leaveAnimation || _ionic_global_c74e4951_js__WEBPACK_IMPORTED_MODULE_6__.c.get('modalLeave', iosLeaveAnimation);
      var ani = this.animation = animationBuilder(el, {
        presentingEl: this.presentingElement
      });
      var contentEl = (0,_index_e6d1a8be_js__WEBPACK_IMPORTED_MODULE_7__.a)(el);

      if (!contentEl) {
        (0,_index_e6d1a8be_js__WEBPACK_IMPORTED_MODULE_7__.p)(el);
        return;
      }

      var statusBarStyle = (_a = this.statusBarStyle) !== null && _a !== void 0 ? _a : Style.Default;
      this.gesture = createSwipeToCloseGesture(el, ani, statusBarStyle, function () {
        /**
         * While the gesture animation is finishing
         * it is possible for a user to tap the backdrop.
         * This would result in the dismiss animation
         * being played again. Typically this is avoided
         * by setting `presented = false` on the overlay
         * component; however, we cannot do that here as
         * that would prevent the element from being
         * removed from the DOM.
         */
        _this4.gestureAnimationDismissing = true;

        _this4.animation.onFinish( /*#__PURE__*/(0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return _this4.dismiss(undefined, _overlays_58fa8e4d_js__WEBPACK_IMPORTED_MODULE_13__.G);

              case 2:
                _this4.gestureAnimationDismissing = false;

              case 3:
              case "end":
                return _context6.stop();
            }
          }, _callee6);
        })));
      });
      this.gesture.enable(true);
    }
  }, {
    key: "initSheetGesture",
    value: function initSheetGesture() {
      var _this5 = this;

      var wrapperEl = this.wrapperEl,
          initialBreakpoint = this.initialBreakpoint,
          backdropBreakpoint = this.backdropBreakpoint;

      if (!wrapperEl || initialBreakpoint === undefined) {
        return;
      }

      var animationBuilder = this.enterAnimation || _ionic_global_c74e4951_js__WEBPACK_IMPORTED_MODULE_6__.c.get('modalEnter', iosEnterAnimation);
      var ani = this.animation = animationBuilder(this.el, {
        presentingEl: this.presentingElement,
        currentBreakpoint: initialBreakpoint,
        backdropBreakpoint: backdropBreakpoint
      });
      ani.progressStart(true, 1);

      var _createSheetGesture = createSheetGesture(this.el, this.backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, ani, this.sortedBreakpoints, function () {
        var _a;

        return (_a = _this5.currentBreakpoint) !== null && _a !== void 0 ? _a : 0;
      }, function () {
        return _this5.sheetOnDismiss();
      }, function (breakpoint) {
        if (_this5.currentBreakpoint !== breakpoint) {
          _this5.currentBreakpoint = breakpoint;

          _this5.ionBreakpointDidChange.emit({
            breakpoint: breakpoint
          });
        }
      }),
          gesture = _createSheetGesture.gesture,
          moveSheetToBreakpoint = _createSheetGesture.moveSheetToBreakpoint;

      this.gesture = gesture;
      this.moveSheetToBreakpoint = moveSheetToBreakpoint;
      this.gesture.enable(true);
    }
  }, {
    key: "sheetOnDismiss",
    value: function sheetOnDismiss() {
      var _this6 = this;

      /**
       * While the gesture animation is finishing
       * it is possible for a user to tap the backdrop.
       * This would result in the dismiss animation
       * being played again. Typically this is avoided
       * by setting `presented = false` on the overlay
       * component; however, we cannot do that here as
       * that would prevent the element from being
       * removed from the DOM.
       */
      this.gestureAnimationDismissing = true;
      this.animation.onFinish( /*#__PURE__*/(0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _this6.currentBreakpoint = 0;

              _this6.ionBreakpointDidChange.emit({
                breakpoint: _this6.currentBreakpoint
              });

              _context7.next = 4;
              return _this6.dismiss(undefined, _overlays_58fa8e4d_js__WEBPACK_IMPORTED_MODULE_13__.G);

            case 4:
              _this6.gestureAnimationDismissing = false;

            case 5:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      })));
    }
    /**
     * Dismiss the modal overlay after it has been presented.
     *
     * @param data Any data to emit in the dismiss events.
     * @param role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.
     */

  }, {
    key: "dismiss",
    value: function () {
      var _dismiss2 = (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(data, role) {
        var _this7 = this;

        var _a, hasCardModal, enteringAnimation, dismissed, _this$getDelegate2, delegate;

        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              if (!(this.gestureAnimationDismissing && role !== _overlays_58fa8e4d_js__WEBPACK_IMPORTED_MODULE_13__.G)) {
                _context8.next = 2;
                break;
              }

              return _context8.abrupt("return", false);

            case 2:
              _context8.t0 = role !== 'handler';

              if (!_context8.t0) {
                _context8.next = 7;
                break;
              }

              _context8.next = 6;
              return this.checkCanDismiss(data, role);

            case 6:
              _context8.t0 = !_context8.sent;

            case 7:
              if (!_context8.t0) {
                _context8.next = 9;
                break;
              }

              return _context8.abrupt("return", false);

            case 9:
              /**
               * We need to start the status bar change
               * before the animation so that the change
               * finishes when the dismiss animation does.
               * TODO (FW-937)
               */
              hasCardModal = this.presentingElement !== undefined && (this.swipeToClose || this.canDismiss !== undefined);

              if (hasCardModal && (0,_ionic_global_c74e4951_js__WEBPACK_IMPORTED_MODULE_6__.b)(this) === 'ios') {
                setCardStatusBarDefault(this.statusBarStyle);
              }
              /* tslint:disable-next-line */


              if (typeof window !== 'undefined' && this.keyboardOpenCallback) {
                window.removeEventListener(_keyboard_282b81b8_js__WEBPACK_IMPORTED_MODULE_10__.KEYBOARD_DID_OPEN, this.keyboardOpenCallback);
                this.keyboardOpenCallback = undefined;
              }
              /**
               * When using an inline modal
               * and presenting a modal it is possible to
               * quickly dismiss the modal while it is
               * presenting. We need to await any current
               * transition to allow the present to finish
               * before dismissing again.
               */


              if (!(this.currentTransition !== undefined)) {
                _context8.next = 15;
                break;
              }

              _context8.next = 15;
              return this.currentTransition;

            case 15:
              enteringAnimation = _overlays_58fa8e4d_js__WEBPACK_IMPORTED_MODULE_13__.h.get(this) || [];
              this.currentTransition = (0,_overlays_58fa8e4d_js__WEBPACK_IMPORTED_MODULE_13__.f)(this, data, role, 'modalLeave', iosLeaveAnimation, mdLeaveAnimation, {
                presentingEl: this.presentingElement,
                currentBreakpoint: (_a = this.currentBreakpoint) !== null && _a !== void 0 ? _a : this.initialBreakpoint,
                backdropBreakpoint: this.backdropBreakpoint
              });
              _context8.next = 19;
              return this.currentTransition;

            case 19:
              dismissed = _context8.sent;

              if (!dismissed) {
                _context8.next = 28;
                break;
              }

              _this$getDelegate2 = this.getDelegate(), delegate = _this$getDelegate2.delegate;
              _context8.next = 24;
              return (0,_framework_delegate_c3305a28_js__WEBPACK_IMPORTED_MODULE_8__.d)(delegate, this.usersElement);

            case 24:
              (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.c)(function () {
                return _this7.el.classList.remove('show-modal');
              });

              if (this.animation) {
                this.animation.destroy();
              }

              if (this.gesture) {
                this.gesture.destroy();
              }

              enteringAnimation.forEach(function (ani) {
                return ani.destroy();
              });

            case 28:
              this.currentBreakpoint = undefined;
              this.currentTransition = undefined;
              this.animation = undefined;
              return _context8.abrupt("return", dismissed);

            case 32:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));

      function dismiss(_x6, _x7) {
        return _dismiss2.apply(this, arguments);
      }

      return dismiss;
    }()
    /**
     * Returns a promise that resolves when the modal did dismiss.
     */

  }, {
    key: "onDidDismiss",
    value: function onDidDismiss() {
      return (0,_overlays_58fa8e4d_js__WEBPACK_IMPORTED_MODULE_13__.g)(this.el, 'ionModalDidDismiss');
    }
    /**
     * Returns a promise that resolves when the modal will dismiss.
     */

  }, {
    key: "onWillDismiss",
    value: function onWillDismiss() {
      return (0,_overlays_58fa8e4d_js__WEBPACK_IMPORTED_MODULE_13__.g)(this.el, 'ionModalWillDismiss');
    }
    /**
     * Move a sheet style modal to a specific breakpoint. The breakpoint value must
     * be a value defined in your `breakpoints` array.
     */

  }, {
    key: "setCurrentBreakpoint",
    value: function () {
      var _setCurrentBreakpoint = (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(breakpoint) {
        var currentBreakpoint, moveSheetToBreakpoint, canDismiss, breakpoints;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              if (this.isSheetModal) {
                _context9.next = 3;
                break;
              }

              (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_11__.p)('setCurrentBreakpoint is only supported on sheet modals.');
              return _context9.abrupt("return");

            case 3:
              if (this.breakpoints.includes(breakpoint)) {
                _context9.next = 6;
                break;
              }

              (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_11__.p)("Attempted to set invalid breakpoint value ".concat(breakpoint, ". Please double check that the breakpoint value is part of your defined breakpoints."));
              return _context9.abrupt("return");

            case 6:
              currentBreakpoint = this.currentBreakpoint, moveSheetToBreakpoint = this.moveSheetToBreakpoint, canDismiss = this.canDismiss, breakpoints = this.breakpoints;

              if (!(currentBreakpoint === breakpoint)) {
                _context9.next = 9;
                break;
              }

              return _context9.abrupt("return");

            case 9:
              if (!moveSheetToBreakpoint) {
                _context9.next = 14;
                break;
              }

              this.sheetTransition = moveSheetToBreakpoint({
                breakpoint: breakpoint,
                breakpointOffset: 1 - currentBreakpoint,
                canDismiss: canDismiss !== undefined && canDismiss !== true && breakpoints[0] === 0
              });
              _context9.next = 13;
              return this.sheetTransition;

            case 13:
              this.sheetTransition = undefined;

            case 14:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));

      function setCurrentBreakpoint(_x8) {
        return _setCurrentBreakpoint.apply(this, arguments);
      }

      return setCurrentBreakpoint;
    }()
    /**
     * Returns the current breakpoint of a sheet style modal
     */

  }, {
    key: "getCurrentBreakpoint",
    value: function () {
      var _getCurrentBreakpoint = (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              return _context10.abrupt("return", this.currentBreakpoint);

            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));

      function getCurrentBreakpoint() {
        return _getCurrentBreakpoint.apply(this, arguments);
      }

      return getCurrentBreakpoint;
    }()
  }, {
    key: "moveToNextBreakpoint",
    value: function () {
      var _moveToNextBreakpoint = (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var breakpoints, currentBreakpoint, allowedBreakpoints, currentBreakpointIndex, nextBreakpointIndex, nextBreakpoint;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              breakpoints = this.breakpoints, currentBreakpoint = this.currentBreakpoint;

              if (!(!breakpoints || currentBreakpoint == null)) {
                _context11.next = 3;
                break;
              }

              return _context11.abrupt("return", false);

            case 3:
              allowedBreakpoints = breakpoints.filter(function (b) {
                return b !== 0;
              });
              currentBreakpointIndex = allowedBreakpoints.indexOf(currentBreakpoint);
              nextBreakpointIndex = (currentBreakpointIndex + 1) % allowedBreakpoints.length;
              nextBreakpoint = allowedBreakpoints[nextBreakpointIndex];
              /**
               * Sets the current breakpoint to the next available breakpoint.
               * If the current breakpoint is the last breakpoint, we set the current
               * breakpoint to the first non-zero breakpoint to avoid dismissing the sheet.
               */

              _context11.next = 9;
              return this.setCurrentBreakpoint(nextBreakpoint);

            case 9:
              return _context11.abrupt("return", true);

            case 10:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));

      function moveToNextBreakpoint() {
        return _moveToNextBreakpoint.apply(this, arguments);
      }

      return moveToNextBreakpoint;
    }()
  }, {
    key: "render",
    value: function render() {
      var _Object$assign,
          _this8 = this;

      var handle = this.handle,
          isSheetModal = this.isSheetModal,
          presentingElement = this.presentingElement,
          htmlAttributes = this.htmlAttributes,
          handleBehavior = this.handleBehavior,
          inheritedAttributes = this.inheritedAttributes;
      var showHandle = handle !== false && isSheetModal;
      var mode = (0,_ionic_global_c74e4951_js__WEBPACK_IMPORTED_MODULE_6__.b)(this);
      var modalId = this.modalId;
      var isCardModal = presentingElement !== undefined && mode === 'ios';
      var isHandleCycle = handleBehavior === 'cycle';
      return (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.h)(_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.H, Object.assign({
        "no-router": true,
        tabindex: "-1"
      }, htmlAttributes, {
        style: {
          zIndex: "".concat(20000 + this.overlayIndex)
        },
        class: Object.assign((_Object$assign = {}, (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_Object$assign, mode, true), (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_Object$assign, 'modal-default', !isCardModal && !isSheetModal), (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_Object$assign, "modal-card", isCardModal), (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_Object$assign, "modal-sheet", isSheetModal), (0,_Users_ricardobento_Documents_AUTOMATION_ionic_e2e_example_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_Object$assign, 'overlay-hidden', true), _Object$assign), (0,_theme_7670341c_js__WEBPACK_IMPORTED_MODULE_14__.g)(this.cssClass)),
        id: modalId,
        onIonBackdropTap: this.onBackdropTap,
        onIonModalDidPresent: this.onLifecycle,
        onIonModalWillPresent: this.onLifecycle,
        onIonModalWillDismiss: this.onLifecycle,
        onIonModalDidDismiss: this.onLifecycle
      }), (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.h)("ion-backdrop", {
        ref: function ref(el) {
          return _this8.backdropEl = el;
        },
        visible: this.showBackdrop,
        tappable: this.backdropDismiss,
        part: "backdrop"
      }), mode === 'ios' && (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
        class: "modal-shadow"
      }), (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.h)("div", Object.assign({
        /*
          role and aria-modal must be used on the
          same element. They must also be set inside the
          shadow DOM otherwise ion-button will not be highlighted
          when using VoiceOver: https://bugs.webkit.org/show_bug.cgi?id=247134
        */
        role: "dialog"
      }, inheritedAttributes, {
        "aria-modal": "true",
        class: "modal-wrapper ion-overlay-wrapper",
        part: "content",
        ref: function ref(el) {
          return _this8.wrapperEl = el;
        }
      }), showHandle && (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.h)("button", {
        class: "modal-handle",
        // Prevents the handle from receiving keyboard focus when it does not cycle
        tabIndex: !isHandleCycle ? -1 : 0,
        "aria-label": "Activate to adjust the size of the dialog overlaying the screen",
        onClick: isHandleCycle ? this.onHandleClick : undefined,
        part: "handle"
      }), (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.h)("slot", null)));
    }
  }, {
    key: "el",
    get: function get() {
      return (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_5__.i)(this);
    }
  }], [{
    key: "watchers",
    get: function get() {
      return {
        "isOpen": ["onIsOpenChange"],
        "trigger": ["onTriggerChange"],
        "swipeToClose": ["swipeToCloseChanged"]
      };
    }
  }]);

  return Modal;
}();

var LIFECYCLE_MAP = {
  ionModalDidPresent: 'ionViewDidEnter',
  ionModalWillPresent: 'ionViewWillEnter',
  ionModalWillDismiss: 'ionViewWillLeave',
  ionModalDidDismiss: 'ionViewDidLeave'
};
var modalIds = 0;
Modal.style = {
  ios: modalIosCss,
  md: modalMdCss
};


/***/ })

}]);
//# sourceMappingURL=node_modules_ionic_core_dist_esm_ion-modal_entry_js.js.map